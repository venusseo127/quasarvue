/*!
 * @quasar/quasar-ui-qcalendar v1.5.7
 * (c) 2020 Jeff Galbraith <jeff@quasar.dev>
 * Released under the MIT License.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('quasar')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'quasar'], factory) :
  (global = global || self, factory(global.QCalendar = {}, global.Vue, global.Quasar));
}(this, (function (exports, Vue, quasar) { 'use strict';

  Vue = Vue && Object.prototype.hasOwnProperty.call(Vue, 'default') ? Vue['default'] : Vue;

  var version = "1.5.7";

  var PARSE_REGEX = /^(\d{4})-(\d{1,2})(-(\d{1,2}))?([^\d]+(\d{1,2}))?(:(\d{1,2}))?(:(\d{1,2}))?(.(\d{1,3}))?$/;
  var PARSE_TIME = /(\d\d?)(:(\d\d?)|)(:(\d\d?)|)/;

  var DAYS_IN_MONTH = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_MIN = 28;
  var DAYS_IN_MONTH_MAX = 31;
  var MONTH_MAX = 12;
  var MONTH_MIN = 1;
  var DAY_MIN = 1;
  var DAYS_IN_WEEK = 7;
  var MINUTES_IN_HOUR = 60;
  var HOURS_IN_DAY = 24;
  var FIRST_HOUR = 0;
  var MILLISECONDS_IN_DAY = 86400000;
  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE = 60000;

  /* eslint-disable no-multi-spaces */
  var Timestamp = {
    date: '',       // YYYY-mm-dd
    time: '',       // 00:00:00 (optional)
    year: 0,        // YYYY
    month: 0,       // mm (Jan = 1, etc)
    day: 0,         // day of the month
    weekday: 0,     // week day
    hour: 0,        // 24-hr
    minute: 0,      // mm
    doy: 0,         // day of year
    workweek: 0,    // workweek number
    hasDay: false,  // if this timestamp is supposed to have a date
    hasTime: false, // if this timestamp is supposed to have a time
    past: false,    // if timestamp is in the past (based on `now` property)
    current: false, // if timestamp is current date (based on `now` property)
    future: false,  // if timestamp is in the future (based on `now` property)
    disabled: false // if timestamp is disabled
  };

  var TimeObject = {
    hour: 0,  // Number
    minute: 0 // Number
  };
  /* eslint-enable no-multi-spaces */

  function getStartOfWeek (timestamp, weekdays, today) {
    var start = copyTimestamp(timestamp);
    if (start.day === 1 || start.weekday === 0) {
      while (!weekdays.includes(start.weekday)) {
        nextDay(start);
      }
    }
    findWeekday(start, weekdays[0], prevDay);
    updateFormatted(start);
    if (today) {
      updateRelative(start, today, start.hasTime);
    }
    return start
  }

  function getEndOfWeek (timestamp, weekdays, today) {
    var end = copyTimestamp(timestamp);
    // is last day of month?
    var lastDay = daysInMonth(end.year, end.month);
    if (lastDay === end.day || end.weekday === 6) {
      while (!weekdays.includes(end.weekday)) {
        prevDay(end);
      }
    }
    findWeekday(end, weekdays[weekdays.length - 1], nextDay);
    updateFormatted(end);
    if (today) {
      updateRelative(end, today, end.hasTime);
    }
    return end
  }

  function getStartOfMonth (timestamp) {
    var start = copyTimestamp(timestamp);
    start.day = DAY_MIN;
    updateFormatted(start);
    return start
  }

  function getEndOfMonth (timestamp) {
    var end = copyTimestamp(timestamp);
    end.day = daysInMonth(end.year, end.month);
    updateFormatted(end);
    return end
  }

  function parseTime (input) {
    var type = Object.prototype.toString.call(input);
    switch (type) {
      case '[object Number]':
        // when a number is given, it's minutes since 12:00am
        return input
      case '[object String]':
      {
        // when a string is given, it's a hh:mm:ss format where seconds are optional
        var parts = PARSE_TIME.exec(input);
        if (!parts) {
          return false
        }
        return parseInt(parts[1], 10) * 60 + parseInt(parts[3] || 0, 10)
      }
      case '[object Object]':
        // when an object is given, it must have hour and minute
        if (typeof input.hour !== 'number' || typeof input.minute !== 'number') {
          return false
        }
        return input.hour * 60 + input.minute
    }

    return false
  }

  function validateTimestamp (input) {
    return !!PARSE_REGEX.exec(input)
  }

  function parsed (input) {
    // YYYY-mm-dd hh:mm:ss
    var parts = PARSE_REGEX.exec(input);

    if (!parts) { return null }

    return {
      date: input,
      time: '',
      year: parseInt(parts[1], 10),
      month: parseInt(parts[2], 10),
      day: parseInt(parts[4], 10) || 1,
      hour: parseInt(parts[6], 10) || 0,
      minute: parseInt(parts[8], 10) || 0,
      weekday: 0,
      doy: 0,
      workweek: 0,
      hasDay: !!parts[4],
      hasTime: !!(parts[6] && parts[8]),
      past: false,
      current: false,
      future: false,
      disabled: false
    }
  }

  function parseTimestamp (input, now) {
    var timestamp = parsed(input);
    if (timestamp === null) { return null }

    updateFormatted(timestamp);

    if (now) {
      updateRelative(timestamp, now, timestamp.hasTime);
    }

    return timestamp
  }

  function parseDate (date) {
    return updateFormatted({
      date: '',
      time: '',
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      day: date.getDate(),
      weekday: date.getDay(),
      hour: date.getHours(),
      minute: date.getMinutes(),
      doy: 0,
      workweek: 0,
      hasDay: true,
      hasTime: true,
      past: false,
      current: true,
      future: false,
      disabled: false
    })
  }

  function getDayIdentifier (timestamp) {
    return timestamp.year * 100000000 + timestamp.month * 1000000 + timestamp.day * 10000
  }

  function getTimeIdentifier (timestamp) {
    return timestamp.hour * 100 + timestamp.minute
  }

  function diffTimestamp (ts1, ts2, strict) {
    var utc1 = Date.UTC(ts1.year, ts1.month - 1, ts1.day, ts1.hour, ts1.minute);
    var utc2 = Date.UTC(ts2.year, ts2.month - 1, ts2.day, ts2.hour, ts2.minute);
    if (strict === true && utc2 < utc1) {
      // Not negative number
      // utc2 - utc1 < 0  -> utc2 < utc1 ->   NO: utc1 >= utc2
      return 0
    }
    return utc2 - utc1
  }

  function updateRelative (timestamp, now, time) {
    if ( time === void 0 ) time = false;

    var a = getDayIdentifier(now);
    var b = getDayIdentifier(timestamp);
    var current = a === b;

    if (timestamp.hasTime && time && current) {
      a = getTimeIdentifier(now);
      b = getTimeIdentifier(timestamp);
      current = a === b;
    }

    timestamp.past = b < a;
    timestamp.current = current;
    timestamp.future = b > a;

    return timestamp
  }

  function updateMinutes (timestamp, minutes, now) {
    timestamp.hasTime = true;
    timestamp.hour = Math.floor(minutes / MINUTES_IN_HOUR);
    timestamp.minute = minutes % MINUTES_IN_HOUR;
    timestamp.time = getTime(timestamp);
    if (now) {
      updateRelative(timestamp, now, true);
    }

    return timestamp
  }

  function updateWeekday (timestamp) {
    timestamp.weekday = getWeekday(timestamp);

    return timestamp
  }

  function updateDayOfYear (timestamp) {
    timestamp.doy = getDayOfYear(timestamp);

    return timestamp
  }

  function updateWorkWeek (timestamp) {
    timestamp.workweek = getWorkWeek(timestamp);

    return timestamp
  }

  function updateDisabled (timestamp, disabledBefore, disabledAfter, disabledWeekdays, disabledDays) {
    var t = getDayIdentifier(timestamp);

    if (disabledBefore !== void 0) {
      var before = getDayIdentifier(parsed(disabledBefore));
      if (t <= before) {
        timestamp.disabled = true;
      }
    }

    if (timestamp.disabled !== true && disabledAfter !== void 0) {
      var after = getDayIdentifier(parsed(disabledAfter));
      if (t >= after) {
        timestamp.disabled = true;
      }
    }

    if (timestamp.disabled !== true && Array.isArray(disabledWeekdays) && disabledWeekdays.length > 0) {
      for (var weekday in disabledWeekdays) {
        if (disabledWeekdays[weekday] === timestamp.weekday) {
          timestamp.disabled = true;
          break
        }
      }
    }

    if (timestamp.disabled !== true && Array.isArray(disabledDays) && disabledDays.length > 0) {
      for (var day in disabledDays) {
        var d = getDayIdentifier(parseTimestamp(disabledDays[day] + ' 00:00'));
        if (d === t) {
          timestamp.disabled = true;
          break
        }
      }
    }

    return timestamp
  }

  function updateFormatted (timestamp) {
    timestamp.time = getTime(timestamp);
    timestamp.date = getDate(timestamp);
    timestamp.weekday = getWeekday(timestamp);
    timestamp.doy = getDayOfYear(timestamp);
    timestamp.workweek = getWorkWeek(timestamp);

    return timestamp
  }

  function getDayOfYear (timestamp) {
    if (timestamp.year === 0) { return }
    return (Date.UTC(timestamp.year, timestamp.month - 1, timestamp.day) - Date.UTC(timestamp.year, 0, 0)) / 24 / 60 / 60 / 1000
  }

  function getWorkWeek (timestamp) {
    if (timestamp.year === 0) { return }
    var ts = makeDate(timestamp);
    return quasar.date.getWeekOfYear(ts)
  }

  function getWeekday (timestamp) {
    if (timestamp.hasDay) {
      var floor = Math.floor;
      var day = timestamp.day;
      var month = ((timestamp.month + 9) % MONTH_MAX) + 1;
      var century = floor(timestamp.year / 100);
      var year = (timestamp.year % 100) - (timestamp.month <= 2 ? 1 : 0);

      return (((day + floor(2.6 * month - 0.2) - 2 * century + year + floor(year / 4) + floor(century / 4)) % 7) + 7) % 7
    }

    return timestamp.weekday
  }

  function isLeapYear (year) {
    return ((year % 4 === 0) ^ (year % 100 === 0) ^ (year % 400 === 0)) === 1
  }

  function daysInMonth (year, month) {
    return isLeapYear(year) ? DAYS_IN_MONTH_LEAP[month] : DAYS_IN_MONTH[month]
  }

  function copyTimestamp (timestamp) {
    return Object.assign({}, timestamp)
  }

  function padNumber (x, length) {
    var padded = String(x);
    while (padded.length < length) {
      padded = '0' + padded;
    }

    return padded
  }

  function getDate (timestamp) {
    var str = (padNumber(timestamp.year, 4)) + "-" + (padNumber(timestamp.month, 2));

    if (timestamp.hasDay) { str += "-" + (padNumber(timestamp.day, 2)); }

    return str
  }

  function getTime (timestamp) {
    if (!timestamp.hasTime) {
      return ''
    }

    return ((padNumber(timestamp.hour, 2)) + ":" + (padNumber(timestamp.minute, 2)))
  }

  function getDateTime (timestamp) {
    return getDate(timestamp) + (timestamp.hasTime ? ' ' + getTime(timestamp) : '')
  }

  function nextDay (timestamp) {
    ++timestamp.day;
    timestamp.weekday = (timestamp.weekday + 1) % DAYS_IN_WEEK;
    if (timestamp.day > DAYS_IN_MONTH_MIN && timestamp.day > daysInMonth(timestamp.year, timestamp.month)) {
      timestamp.day = DAY_MIN;
      ++timestamp.month;
      if (timestamp.month > MONTH_MAX) {
        timestamp.month = MONTH_MIN;
        ++timestamp.year;
      }
    }

    return timestamp
  }

  function prevDay (timestamp) {
    timestamp.day--;
    timestamp.weekday = (timestamp.weekday + 6) % DAYS_IN_WEEK;
    if (timestamp.day < DAY_MIN) {
      timestamp.month--;
      if (timestamp.month < MONTH_MIN) {
        timestamp.year--;
        timestamp.month = MONTH_MAX;
      }
      timestamp.day = daysInMonth(timestamp.year, timestamp.month);
    }

    return timestamp
  }

  // Giiving a name that is easier to userstand
  function moveRelativeDays (timestamp, mover, days, allowedWeekdays) {
    if ( mover === void 0 ) mover = nextDay;
    if ( days === void 0 ) days = 1;
    if ( allowedWeekdays === void 0 ) allowedWeekdays = [0, 1, 2, 3, 4, 5, 6];

    return relativeDays(timestamp, mover, days, allowedWeekdays)
  }

  // Keeping this one so nothing breaks
  function relativeDays (timestamp, mover, days, allowedWeekdays) {
    if ( mover === void 0 ) mover = nextDay;
    if ( days === void 0 ) days = 1;
    if ( allowedWeekdays === void 0 ) allowedWeekdays = [0, 1, 2, 3, 4, 5, 6];

    while (--days >= 0) {
      mover(timestamp);
      if (allowedWeekdays.length < 7 && !allowedWeekdays.includes(timestamp.weekday)) {
        ++days;
      }
    }

    return timestamp
  }

  function findWeekday (timestamp, weekday, mover, maxDays) {
    if ( mover === void 0 ) mover = nextDay;
    if ( maxDays === void 0 ) maxDays = 6;

    while (timestamp.weekday !== weekday && --maxDays >= 0) { mover(timestamp); }
    return timestamp
  }

  function getWeekdaySkips (weekdays) {
    var skips = [1, 1, 1, 1, 1, 1, 1];
    var filled = [0, 0, 0, 0, 0, 0, 0];
    for (var i = 0; i < weekdays.length; ++i) {
      filled[weekdays[i]] = 1;
    }
    for (var k = 0; k < DAYS_IN_WEEK; ++k) {
      var skip = 1;
      for (var j = 1; j < DAYS_IN_WEEK; ++j) {
        var next = (k + j) % DAYS_IN_WEEK;
        if (filled[next]) {
          break
        }
        ++skip;
      }
      skips[k] = filled[k] * skip;
    }

    return skips
  }

  function createDayList (start, end, now, weekdaySkips, disabledBefore, disabledAfter, disabledWeekdays, disabledDays, max, min) {
    if ( disabledWeekdays === void 0 ) disabledWeekdays = [];
    if ( disabledDays === void 0 ) disabledDays = [];
    if ( max === void 0 ) max = 42;
    if ( min === void 0 ) min = 0;

    var stop = getDayIdentifier(end);
    var days = [];
    var current = copyTimestamp(start);
    var currentIdentifier = 0;
    var stopped = currentIdentifier === stop;

    if (stop < getDayIdentifier(start)) {
      return days
    }

    while ((!stopped || days.length < min) && days.length < max) {
      currentIdentifier = getDayIdentifier(current);
      stopped = stopped || currentIdentifier > stop;
      if (stopped) {
        break
      }
      if (weekdaySkips[current.weekday] === 0) {
        current = nextDay(current);
        continue
      }
      var day = copyTimestamp(current);
      updateFormatted(day);
      updateRelative(day, now);
      updateDisabled(day, disabledBefore, disabledAfter, disabledWeekdays, disabledDays);
      days.push(day);
      // current = relativeDays(current, nextDay, weekdaySkips[current.weekday])
      current = relativeDays(current, nextDay);
    }

    return days
  }

  function createIntervalList (timestamp, first, minutes, count, now) {
    var intervals = [];

    for (var i = 0; i < count; ++i) {
      var mins = (first + i) * minutes;
      var int = copyTimestamp(timestamp);
      intervals.push(updateMinutes(int, mins, now));
    }

    return intervals
  }

  function createNativeLocaleFormatter (locale, getOptions) {
    var emptyFormatter = function (_t, _s) { return ''; };

    if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {
      return emptyFormatter
    }

    return function (timestamp, short) {
      try {
        var intlFormatter = new Intl.DateTimeFormat(locale || void 0, getOptions(timestamp, short));
        return intlFormatter.format(makeDateTime(timestamp))
      } catch (e) {
        return ''
      }
    }
  }

  function makeDate (timestamp) {
    return new Date(Date.UTC(timestamp.year, timestamp.month - 1, timestamp.day, 0, 0))
  }

  function makeDateTime (timestamp) {
    return new Date(Date.UTC(timestamp.year, timestamp.month - 1, timestamp.day, timestamp.hour, timestamp.minute))
  }

  function validateNumber (input) {
    return isFinite(parseInt(input, 10))
  }

  function isBetweenDates (timestamp, startTimestamp, endTimestamp, useTime /* = false */) {
    var cd = getDayIdentifier(timestamp) + (useTime === true ? getTimeIdentifier(timestamp) : 0);
    var sd = getDayIdentifier(startTimestamp) + (useTime === true ? getTimeIdentifier(startTimestamp) : 0);
    var ed = getDayIdentifier(endTimestamp) + (useTime === true ? getTimeIdentifier(endTimestamp) : 0);

    return cd >= sd && cd <= ed
  }

  function isOverlappingDates (startTimestamp, endTimestamp, firstTimestamp, lastTimestamp) {
    var start = getDayIdentifier(startTimestamp);
    var end = getDayIdentifier(endTimestamp);
    var first = getDayIdentifier(firstTimestamp);
    var last = getDayIdentifier(lastTimestamp);
    return (
      (start >= first && start <= last) || // overlap left
      (end >= first && end <= last) || // overlap right
      (first >= start && end >= last) // surrounding
    )
  }

  function addToDate (timestamp, options) {
    var ts = copyTimestamp(timestamp);
    var minType;
    __forEachObject(options, function (value, key) {
      if (ts[key] !== void 0) {
        ts[key] += parseInt(value, 10);
        var indexType = NORMALIZE_TYPES.indexOf(key);
        if (indexType !== -1) {
          if (minType === void 0) {
            minType = indexType;
          } else {
            minType = Math.min(indexType, minType);
          }
        }
      }
    });

    // normalize timestamp
    if (minType !== void 0) {
      __normalize(ts, NORMALIZE_TYPES[minType]);
    }
    updateFormatted(ts);
    return ts
  }

  var NORMALIZE_TYPES = ['minute', 'hour', 'day', 'month'];

  // addToDate helper
  function __forEachObject (obj, cb) {
    Object.keys(obj).forEach(function (k) { return cb(obj[k], k); });
  }

  // normalize minutes
  function __normalizeMinute (ts) {
    if (ts.minute >= MINUTES_IN_HOUR || ts.minute < 0) {
      var hours = Math.floor(ts.minute / MINUTES_IN_HOUR);
      ts.minute -= hours * MINUTES_IN_HOUR;
      ts.hour += hours;
      __normalizeHour(ts);
    }
    return ts
  }

  // normalize hours
  function __normalizeHour (ts) {
    if (ts.hour >= HOURS_IN_DAY || ts.hour < 0) {
      var days = Math.floor(ts.hour / HOURS_IN_DAY);
      ts.hour -= days * HOURS_IN_DAY;
      ts.day += days;
      __normalizeDay(ts);
    }
    return ts
  }

  // normalize days
  function __normalizeDay (ts) {
    __normalizeMonth(ts);
    var dim = daysInMonth(ts.year, ts.month);
    if (ts.day > dim) {
      ++ts.month;
      if (ts.month > MONTH_MAX) {
        __normalizeMonth(ts);
      }
      var days = ts.day - dim;
      dim = daysInMonth(ts.year, ts.month);
      do {
        if (days > dim) {
          ++ts.month;
          if (ts.month > MONTH_MAX) {
            __normalizeMonth(ts);
          }
          days -= dim;
          dim = daysInMonth(ts.year, ts.month);
        }
      } while (days > dim)
      ts.day = days;
    } else if (ts.day <= 0) {
      var days$1 = -1 * ts.day;
      --ts.month;
      if (ts.month <= 0) {
        __normalizeMonth(ts);
      }
      dim = daysInMonth(ts.year, ts.month);
      do {
        if (days$1 > dim) {
          days$1 -= dim;
          --ts.month;
          if (ts.month <= 0) {
            __normalizeMonth(ts);
          }
          dim = daysInMonth(ts.year, ts.month);
        }
      } while (days$1 > dim)
      ts.day = dim - days$1;
    }
    return ts
  }

  // normalize months
  function __normalizeMonth (ts) {
    if (ts.month > MONTH_MAX) {
      var years = Math.floor(ts.month / MONTH_MAX);
      ts.month = ts.month % MONTH_MAX;
      ts.year += years;
    } else if (ts.month < MONTH_MIN) {
      ts.month += MONTH_MAX;
      --ts.year;
    }
    return ts
  }

  // normalize all
  function __normalize (ts, type) {
    switch (type) {
      case 'minute':
        return __normalizeMinute(ts)
      case 'hour':
        return __normalizeHour(ts)
      case 'day':
        return __normalizeDay(ts)
      case 'month':
        return __normalizeMonth(ts)
    }
  }

  function daysBetween (ts1, ts2) {
    var diff = diffTimestamp(ts1, ts2, true);
    return Math.floor(diff / MILLISECONDS_IN_DAY)
  }

  function weeksBetween (ts1, ts2) {
    var t1 = copyTimestamp(ts1);
    var t2 = copyTimestamp(ts2);
    t1 = findWeekday(t1, 0);
    t2 = findWeekday(t2, 6);
    return Math.ceil(daysBetween(t1, t2) / DAYS_IN_WEEK)
  }

  var Times = {
    name: 'Times',

    props: {
      now: {
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      }
    },

    data: function () { return ({
      times: {
        now: parseTimestamp('0000-00-00 00:00'),
        today: parseTimestamp('0000-00-00')
      }
    }); },

    computed: {
      parsedNow: function parsedNow () {
        return this.now ? parseTimestamp(this.now) : null
      }
    },

    watch: {
      parsedNow: 'updateCurrent'
    },

    beforeMount: function beforeMount () {
      this.updateCurrent();
      this.setCurrent();
    },

    methods: {
      setCurrent: function setCurrent () {
        this.times.now.current = this.times.today.current = true;
        this.times.now.past = this.times.today.past = false;
        this.times.now.future = this.times.today.future = false;
      },

      updateCurrent: function updateCurrent () {
        var now = this.parsedNow || this.getNow();
        this.updateDay(now, this.times.now);
        this.updateTime(now, this.times.now);
        this.updateDay(now, this.times.today);
      },

      getNow: function getNow () {
        return parseDate(new Date())
      },

      updateDay: function updateDay (now, target) {
        if (now.date !== target.date) {
          target.year = now.year;
          target.month = now.month;
          target.day = now.day;
          target.weekday = now.weekday;
          target.date = now.date;
        }
      },

      updateTime: function updateTime (now, target) {
        if (now.time !== target.time) {
          target.hour = now.hour;
          target.minute = now.minute;
          target.time = now.time;
        }
      }
    }
  };

  var Mouse = {
    name: 'Mouse',

    methods: {
      getDefaultMouseEventHandlers: function getDefaultMouseEventHandlers (suffix, getEvent) {
        var obj;

        return this.getMouseEventHandlers(( obj = {}, obj['click' + suffix] = { event: 'click' }, obj['contextmenu' + suffix] = { event: 'contextmenu', prevent: true, result: false }, obj['mousedown' + suffix] = { event: 'mousedown' }, obj['mousemove' + suffix] = { event: 'mousemove' }, obj['mouseup' + suffix] = { event: 'mouseup' }, obj['mouseenter' + suffix] = { event: 'mouseenter' }, obj['mouseleave' + suffix] = { event: 'mouseleave' }, obj['touchstart' + suffix] = { event: 'touchstart' }, obj['touchmove' + suffix] = { event: 'touchmove' }, obj['touchend' + suffix] = { event: 'touchend' }, obj ), getEvent)
      },
      getMouseEventHandlers: function getMouseEventHandlers (events, getEvent) {
        var this$1 = this;

        var on = {};

        var loop = function ( event ) {
          var eventOptions = events[event];

          if (!this$1.$listeners[event]) { return }

          // https://vuejs.org/v2/guide/render-function.html#Event-amp-Key-Modifiers
          var prefix = eventOptions.passive ? '&' : ((eventOptions.once ? '~' : '') + (eventOptions.capture ? '!' : ''));
          var key = prefix + eventOptions.event;

          var handler = function (e) {
            var mouseEvent = e;
            if (eventOptions.button === void 0 || (mouseEvent.buttons > 0 && mouseEvent.button === eventOptions.button)) {
              if (eventOptions.prevent) {
                e.preventDefault();
              }
              if (eventOptions.stop) {
                e.stopPropagation();
              }
              this$1.$emit(event, getEvent(e));
            }

            return eventOptions.result
          };

          if (key in on) {
            if (Array.isArray(on[key])) {
              (on[key]).push(handler);
            } else {
              on[key] = [on[key], handler];
            }
          } else {
            on[key] = handler;
          }
        };

        for (var event in events) loop( event );

        return on
      }
    }
  };

  /*!
   * q-colorize-mixin v1.0.6
   * (c) 2019 Jeff Galbraith <jeff@quasar.dev>
   * Released under the MIT License.
   */
  var version$1="1.0.6",CSS_COLOR_NAMES=["transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"],QColorizeMixin={name:"QColorizeMixin",props:{color:String},methods:{isNamedCssColor:function(e){return !!e&&CSS_COLOR_NAMES.includes(e.toLowerCase())},isCssColor:function(e){return !!e&&(!!e.match(/^(#|(rgb|hsl)a?\()/)||this.isNamedCssColor(e))},isCssVar:function(e){return !!e&&e.startsWith("--")},calculateColor:function(e,r){return void 0===r&&(r="black"),void 0===e&&void 0!==r?this.calculateColor(r):this.isCssColor(e)?e:this.makeQuasarColorVar(e,r)},makeQuasarColorVar:function(e,r){return "var("+(this.isCssVar(e)?e:"--q-color-"+e)+", '"+r+"')"},isValidCssColor:function(e){return this.isCssColor(e)||this.isCssVar(e)},setBothColors:function(e,r,o){return void 0===o&&(o={}),this.setTextColor(e,this.setBackgroundColor(r,o))},setBackgroundColor:function(e,r){var o;if(void 0===r&&(r={}),this.isValidCssColor(e)){var i=this.calculateColor(e);void 0===r.style&&(r.style={}),r.style=Object.assign({},r.style,{"background-color":""+i});}else if(e){var l=e.toString().trim();void 0===r.class&&(r.class={}),r.class=Object.assign({},r.class,((o={})["bg-"+l]=!0,o));}return r},setTextColor:function(e,r){var o;if(void 0===r&&(r={}),this.isValidCssColor(e)){var i=this.calculateColor(e);void 0===r.style&&(r.style={}),r.style=Object.assign({},r.style,{color:""+i,"caret-color":""+i});}else if(e){var l=e.toString().trim();void 0===r.class&&(r.class={}),r.class=Object.assign({},r.class,((o={})["text-"+l]=!0,o));}return r},setBorderColor:function(e,r){var o;if(void 0===r&&(r={}),this.isValidCssColor(e)){var i=this.calculateColor(e);void 0===r.style&&(r.style={}),r.style=Object.assign({},r.style,{"border-color":""+i});}else if(e){var l=e.toString().trim();void 0===r.class&&(r.class={}),r.class=Object.assign({},r.class,((o={})["border-"+l]=!0,o));}return r}}};QColorizeMixin.version=version$1;

  /*!
   * q-theme-mixin v1.0.1
   * (c) 2019 Jeff Galbraith <jeff@quasar.dev>
   * Released under the MIT License.
   */
  var version$2="1.0.1",QThemeMixin={name:"QThemeMixin",props:{theme:{type:Object,default:function(){}},enableTheme:Boolean},methods:{useDefaultTheme:function(e,n,i){return void 0===i&&(i={}),i},getThemeColors:function(e){var n=this;void 0===e&&(e=[]);var i=new Map;return !0===this.enableTheme&&void 0!==this.theme&&e.forEach(function(e){i.set(e,n.theme[e]);}),i}}};QThemeMixin.version=version$2;

  function validateView (view) {
    return [
      'month', 'week', 'day',
      '2day', '3day', '4day', '5day', '6day',
      'month-scheduler', 'week-scheduler', 'custom-scheduler',
      'scheduler', 'day-scheduler', '2day-scheduler', '3day-scheduler',
      '4day-scheduler', '5day-scheduler', '6day-scheduler',
      'month-agenda', 'week-agenda', 'custom-agenda',
      'agenda', 'day-agenda', '2day-agenda', '3day-agenda',
      '4day-agenda', '5day-agenda', '6day-agenda',
      'month-interval', 'custom-interval'].includes(view)
  }

  /* public properties */
  var props = {
    base: {
      value: { // v-model
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      },
      weekdays: {
        type: Array,
        default: function () { return [0, 1, 2, 3, 4, 5, 6]; }
      },
      noActiveDate: Boolean,
      disabledDays: Array,
      disabledBefore: String,
      disabledAfter: String,
      disabledWeekdays: {
        type: Array,
        default: function () { return []; }
      },
      hideHeader: Boolean,
      noScroll: Boolean,
      shortWeekdayLabel: Boolean,
      noDefaultHeaderText: Boolean,
      noDefaultHeaderBtn: Boolean,
      locale: {
        type: String,
        default: 'en-us'
      },
      animated: Boolean,
      transitionPrev: {
        type: String,
        default: 'slide-right'
      },
      transitionNext: {
        type: String,
        default: 'slide-left'
      },
      dragOverFunc: {
        type: Function
        // event, timestamp
      },
      dropFunc: {
        type: Function
        // event, timestamp
      }
    },
    intervals: {
      value: { // v-model
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      },
      maxDays: {
        type: Number,
        default: 7
      },
      shortIntervalLabel: Boolean,
      intervalHeight: {
        type: [Number, String],
        default: 40,
        validator: validateNumber
      },
      intervalMinutes: {
        type: [Number, String],
        default: 60,
        validator: validateNumber
      },
      intervalStart: {
        type: [Number, String],
        default: 0,
        validator: validateNumber
      },
      intervalCount: {
        type: [Number, String],
        default: 24,
        validator: validateNumber
      },
      intervalStyle: {
        type: Function,
        default: null
      },
      showIntervalLabel: {
        type: Function,
        default: null
      },
      hour24Format: Boolean,
      columnHeaderBefore: Boolean,
      columnHeaderAfter: Boolean,
      columnCount: {
        type: [Number, String],
        default: 1,
        validator: validateNumber
      },
      columnIndexStart: {
        type: [Number, String],
        default: 0,
        validator: validateNumber
      }
    },
    weeks: {
      value: { // v-model
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      },
      dayHeight: {
        type: [Number, String],
        default: 0,
        validator: validateNumber
      },
      dayStyle: {
        type: Function,
        default: null
      },
      dayClass: {
        type: Function,
        default: null
      },
      dayPadding: String,
      minWeeks: {
        type: [Number, String],
        validator: validateNumber,
        default: 1
      },
      shortMonthLabel: Boolean,
      showWorkWeeks: Boolean,
      showMonthLabel: {
        type: Boolean,
        default: true
      },
      showDayOfYearLabel: Boolean,
      selectedStartEndDates: {
        type: Array,
        default: function () { return []; },
        validator: function (v) { return v.length <= 2; }
      },
      selectedDates: Array,
      miniMode: {
        type: [Boolean, String],
        validator: function (v) { return v === void 0 || v === true || v === false || v === 'auto'; }
      },
      breakpoint: {
        type: String,
        default: 'md',
        validator: function (v) { return ['xs', 'sm', 'md', 'lg', 'xl'].includes(v); }
      },
      monthLabelSize: {
        type: String,
        default: 'md',
        validator: function (v) { return ['xs', 'sm', 'md', 'lg', 'xl'].includes(v); }
      }
    },
    scheduler: {
      value: { // v-model
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      },
      resources: Array,
      resourceKey: {
        type: String,
        default: 'label'
      },
      maxDays: {
        type: Number,
        default: 7
      },
      resourceHeight: {
        type: [Number, String],
        default: 70,
        validator: validateNumber
      },
      resourceWidth: {
        type: [Number, String],
        validator: function (v) { return v === void 0 || validateNumber(v); }
      },
      resourceStyle: {
        type: Function,
        default: null
      },
      columnHeaderBefore: Boolean,
      columnHeaderAfter: Boolean,
      columnCount: {
        type: [Number, String],
        default: 1,
        validator: validateNumber
      },
      columnIndexStart: {
        type: [Number, String],
        default: 0,
        validator: validateNumber
      }
    },
    agenda: {
      leftColumnOptions: Array,
      rightColumnOptions: Array,
      columnOptionsId: String,
      columnOptionsLabel: String
    },
    calendar: {
      view: {
        type: String,
        default: 'month',
        validator: validateView
      },
      value: { // v-model
        type: String,
        validator: function (v) { return v === '' || validateTimestamp(v); }
      },
      bordered: Boolean,
      dark: Boolean
    }
  };

  // Mixins

  var CalendarBase = {
    name: 'CalendarBase',

    mixins: [
      QColorizeMixin,
      QThemeMixin,
      Mouse,
      Times
    ],

    props: Object.assign({}, props.base,
      {start: {
        type: String,
        validator: validateTimestamp,
        default: function () { return parseDate(new Date()).date; }
      },
      end: {
        type: String,
        validator: validateTimestamp,
        default: '0000-00-00'
      }}),

    data: function data () {
      return {
        keyValue: 0,
        direction: 'next'
      }
    },

    computed: {
      weekdaySkips: function weekdaySkips () {
        return getWeekdaySkips(this.weekdays)
      },

      parsedStart: function parsedStart () {
        return parseTimestamp(this.start)
      },

      parsedEnd: function parsedEnd () {
        return parseTimestamp(this.end)
      },

      days: function days () {
        return createDayList(
          this.parsedStart,
          this.parsedEnd,
          this.times.today,
          this.weekdaySkips,
          this.disabledBefore,
          this.disabledAfter,
          this.disabledWeekdays,
          this.disabledDays
        )
      },

      dayFormatter: function dayFormatter () {
        var options = { timeZone: 'UTC', day: 'numeric' };

        return createNativeLocaleFormatter(
          this.locale,
          function (_tms, _short) { return options; }
        )
      },

      weekdayFormatter: function weekdayFormatter () {
        var longOptions = { timeZone: 'UTC', weekday: 'long' };
        var shortOptions = { timeZone: 'UTC', weekday: 'short' };

        return createNativeLocaleFormatter(
          this.locale,
          function (_tms, short) { return short ? shortOptions : longOptions; }
        )
      }
    },

    methods: {
      arrayHasDate: function arrayHasDate (arr, timestamp) {
        return arr && arr.length > 0 && arr.includes(timestamp.date)
      },

      getRelativeClasses: function getRelativeClasses (timestamp, outside, selectedDays) {
        if ( outside === void 0 ) outside = false;

        return {
          'q-current-day': timestamp.current,
          'q-past-day': timestamp.past,
          'q-future-day': timestamp.future,
          'q-outside': outside, // outside the current month
          'q-selected-date': this.arrayHasDate(selectedDays, timestamp)
        }
      },

      getStartOfWeek: function getStartOfWeek$1 (timestamp) {
        return getStartOfWeek(timestamp, this.weekdays, this.times.today)
      },

      getEndOfWeek: function getEndOfWeek$1 (timestamp) {
        return getEndOfWeek(timestamp, this.weekdays, this.times.today)
      },

      dayStyleDefault: function dayStyleDefault (_timestamp) {
        return undefined
      }
    }
  };

  function convertToUnit (input, unit) {
    if ( unit === void 0 ) unit = 'px';

    if (input == null || input === '') {
      return void 0
    } else if (isNaN(input)) {
      return String(input)
    } else {
      return ("" + (Number(input)) + unit)
    }
  }

  function indexOf (array, cb) {
    for (var i = 0; i < array.length; i++) {
      if (cb(array[i], i) === true) {
        return i
      }
    }
    return -1
  }

  // Quasar

  var QCalendarWeekly = {
    name: 'QCalendarWeekly',

    mixins: [
      CalendarBase
    ],

    props: props.weeks,

    computed: {
      staticClass: function staticClass () {
        return (this.isMiniMode ? ' q-calendar-mini ' : '') + 'q-calendar-weekly'
      },

      parsedMinWeeks: function parsedMinWeeks () {
        return parseInt(this.minWeeks, 10)
      },

      days: function days () {
        var minDays = this.parsedMinWeeks * this.weekdays.length;
        var start = this.getStartOfWeek(this.parsedStart);
        var end = this.getEndOfWeek(this.parsedEnd);

        return createDayList(
          start,
          end,
          this.times.today,
          this.weekdaySkips,
          this.disabledBefore,
          this.disabledAfter,
          this.disabledWeekdays,
          this.disabledDays,
          Number.MAX_SAFE_INTEGER,
          minDays
        )
      },

      todayWeek: function todayWeek () {
        var today = this.times.today;
        var start = this.getStartOfWeek(today);
        var end = this.getEndOfWeek(today);

        return createDayList(
          start,
          end,
          today,
          this.weekdaySkips,
          this.disabledBefore,
          this.disabledAfter,
          this.disabledWeekdays,
          this.disabledDays,
          this.weekdays.length,
          this.weekdays.length
        )
      },

      monthFormatter: function monthFormatter () {
        var longOptions = { timeZone: 'UTC', month: 'long' };
        var shortOptions = { timeZone: 'UTC', month: 'short' };

        return createNativeLocaleFormatter(
          this.locale,
          function (_tms, short) { return short ? shortOptions : longOptions; }
        )
      },

      styles: function styles () {
        var style = {};
        if (this.dayHeight > 0) {
          var height = convertToUnit(this.dayHeight);
          style.height = height;
        }
        if (this.dayPadding !== void 0) {
          style.padding = this.dayPadding;
        }
        style.width = 100 / this.weekdays.length + '%';
        return style
      },

      isMiniMode: function isMiniMode () {
        return this.miniMode === true ||
          (this.miniMode === 'auto' && this.$q.screen.lt[this.breakpoint])
      }
    },

    methods: {
      isOutside: function isOutside (day) {
        var dayIdentifier = getDayIdentifier(day);

        return dayIdentifier < getDayIdentifier(this.parsedStart) ||
               dayIdentifier > getDayIdentifier(this.parsedEnd)
      },

      isCurrentWeek: function isCurrentWeek (week) {
        for (var i = 0; i < week.length; ++i) {
          if (week[i].current === true) {
            return { timestamp: week[i] }
          }
        }
        return { timestamp: false }
      },

      __renderHead: function __renderHead (h) {
        return h('div', {
          staticClass: 'q-calendar-weekly__head'
        }, [
          this.showWorkWeeks === true && this.__renderWorkWeekHead(h),
          this.__renderHeadDays(h)
        ])
      },

      __renderWorkWeekHead: function __renderWorkWeekHead (h) {
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorHeader';
          backgroundColor = 'backgroundHeader';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-weekly__head-workweek'
        }), '#')
      },

      __renderHeadDays: function __renderHeadDays (h) {
        var this$1 = this;

        return this.todayWeek.map(function (day, index) { return this$1.__renderHeadDay(h, day, index); })
      },

      __renderHeadDay: function __renderHeadDay (h, day, index) {
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorHeader';
          backgroundColor = 'backgroundHeader';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date,
          staticClass: 'q-calendar-weekly__head-weekday',
          style: {
            width: 100 / this.weekdays.length + '%'
          }
        }), [
          this.__renderHeadDayLabel(h, day, this.shortWeekdayLabel || this.isMiniMode)
        ])
      },

      __renderHeadDayLabel: function __renderHeadDayLabel (h, day, label) {
        var weekdayLabel = this.weekdayFormatter(day, label);
        return h('span', {
          staticClass: 'ellipsis'
        }, this.isMiniMode === true && this.shortWeekdayLabel === true ? weekdayLabel.charAt(0) : weekdayLabel)
      },

      __renderWeeks: function __renderWeeks (h) {
        var days = this.days;
        var weekDays = this.weekdays.length;
        var weeks = [];
        for (var i = 0; i < days.length; i += weekDays) {
          weeks.push(this.__renderWeek(h, days.slice(i, i + weekDays)));
        }

        return weeks
      },

      __renderWeek: function __renderWeek (h, week) {
        var this$1 = this;

        var slot = this.$scopedSlots.week;
        var weekdays = this.weekdays;
        var slotData = { week: week, weekdays: weekdays, miniMode: this.isMiniMode };
        var height = convertToUnit(this.dayHeight);
        return h('div', {
          key: week[0].date,
          staticClass: 'q-calendar-weekly__week--wrapper',
          style: {
            height: this.dayHeight && this.dayHeight > 0 ? height : (this.isMiniMode ? 'auto' : 'auto')
          }
        }, [
          this.showWorkWeeks === true && this.__renderWorkWeekGutter(h, week),
          h('div', {
            key: week[0].date,
            staticClass: 'q-calendar-weekly__week'
          }, [
            h('div', {
              staticClass: 'q-calendar-weekly__week-days'
            }, week.map(function (day) { return this$1.__renderDay(h, day); })),
            slot !== void 0 ? h('div', {
              staticClass: 'q-calendar-weekly__week-events'
            }, slot(slotData)) : ''
          ])
        ])
      },

      __renderWorkWeekGutter: function __renderWorkWeekGutter (h, week) {
        var slot = this.$scopedSlots.workweek;
        // adjust day to account for Sunday/Monday start of week calendars
        var day = week.length > 2 ? week[2] : week[0];
        var ref = this.isCurrentWeek(week);
        var timestamp = ref.timestamp;
        var workweekLabel = Number(day.workweek).toLocaleString(this.locale);
        var slotData = { workweekLabel: workweekLabel, week: week, miniMode: this.isMiniMode };
        var colorCurrent = timestamp && timestamp.current === true ? this.color : void 0;
        var height = convertToUnit(this.dayHeight);
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if ((timestamp && timestamp.current === true) || day.current === true) {
            color = 'colorWorkWeekCurrent';
            backgroundColor = 'backgroundWorkWeekCurrent';
          } else if ((timestamp && timestamp.past === true) || day.past === true) {
            color = 'colorWorkWeekPast';
            backgroundColor = 'backgroundWorkWeekPast';
          } else if ((timestamp && timestamp.future === true) || day.future === true) {
            color = 'colorWorkWeekFuture';
            backgroundColor = 'backgroundWorkWeekFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          key: day.workweek,
          staticClass: 'q-calendar-weekly__workweek',
          class: this.getRelativeClasses(timestamp !== false ? timestamp : day, false),
          style: {
            height: this.dayHeight && this.dayHeight > 0 ? height : 'auto'
          },
          on: this.getDefaultMouseEventHandlers(':workweek', function (event) {
            var scope = slotData;
            return { scope: scope, event: event }
          })
        }), slot ? slot(slotData) : workweekLabel)
      },

      __renderDay: function __renderDay (h, day) {
        var this$1 = this;

        var styler = this.dayStyle || this.dayStyleDefault;
        var outside = this.isOutside(day);
        var slot = this.$scopedSlots.day;
        var slotData = Object.assign({}, {outside: outside}, day, {miniMode: this.isMiniMode});
        var hasMonth = (outside === false && this.days.find(function (d) { return d.month === day.month; }).day === day.day && this.showMonthLabel === true);

        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (outside === true) {
            color = 'colorBodyOutside';
            backgroundColor = 'backgroundBodyOutside';
          } else if (day.past === true) {
            color = 'colorBodyPast';
            backgroundColor = 'backgroundBodyPast';
          } else if (day.current === true) {
            color = 'colorBodyCurrent';
            backgroundColor = 'backgroundBodyCurrent';
          } else if (day.future === true) {
            color = 'colorBodyFuture';
            backgroundColor = 'backgroundBodyFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        var style = Object.assign(Object.assign({}, this.styles), styler(day));
        var dayClass = typeof this.dayClass === 'function' ? this.dayClass(day) : null;

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date,
          staticClass: 'q-calendar-weekly__day',
          class: [
            dayClass,
            Object.assign({}, this.getRelativeClasses(day, outside, this.isMiniMode ? void 0 : this.selectedDates),
              {'q-calendar-weekly__day--droppable': dragOver})
          ],
          style: style,
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, day, 'day');
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, day, 'day');
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':day', function (event) {
            var scope = day;
            return { scope: scope, event: event }
          })
        }), [
          this.__renderDayLabel(h, day),
          this.isMiniMode !== true && this.showDayOfYearLabel && !hasMonth ? this.__renderDayOfYearLabel(h, day) : '',
          this.isMiniMode !== true && hasMonth ? this.__renderDayMonth(h, day) : '',
          h('div', {
            staticClass: 'q-calendar-weekly__day--content full-width' + (this.isMiniMode === true ? ' row justify-around' : '')
          }, slot ? slot(slotData) : '')
        ])
      },

      __renderDayLabel: function __renderDayLabel (h, day) {
        var outside = this.isOutside(day);
        var colorCurrent = day.current === true ? this.color : void 0;
        var dayLabel = this.dayFormatter(day, false);
        var slot = this.$scopedSlots['day-label'];
        var slotData = Object.assign({}, {dayLabel: dayLabel}, day, {miniMode: this.isMiniMode});
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;

        var selectedDate = (
          this.isMiniMode &&
          this.selectedDates &&
          this.selectedDates.length > 0 &&
          this.selectedDates.includes(day.date)
        );
        var activeDate = this.value === day.date;

        if (this.enableTheme === true) {
          if (outside === true) {
            color = 'colorDayLabelOutside';
            backgroundColor = 'backgroundDayLabelOutside';
          } else if (day.past === true) {
            color = 'colorDayLabelPast';
            backgroundColor = 'backgroundDayLabelPast';
          } else if (day.current === true) {
            color = 'colorDayLabelCurrent';
            backgroundColor = 'backgroundDayLabelCurrent';
          } else if (day.future === true) {
            color = 'colorDayLabelFuture';
            backgroundColor = 'backgroundDayLabelFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h(quasar.QBtn, updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-weekly__day-label',
          class: [
            {
              'q-selected-date': selectedDate,
              'q-active-date': this.noActiveDate !== true && activeDate
            }
          ],
          props: {
            size: this.isMiniMode ? 'sm' : this.monthLabelSize,
            unelevated: true,
            round: true,
            dense: true,
            noCaps: true,
            outline: day.current === true,
            disable: day.disabled === true || outside === true
          },
          on: this.getMouseEventHandlers({
            'click:date': { event: 'click', stop: true },
            'contextmenu:date': { event: 'contextmenu', stop: true, prevent: true, result: false }
          }, function (_event) { return day; })
        }), [
          slot ? slot(slotData) : dayLabel
        ])
      },

      __renderDayOfYearLabel: function __renderDayOfYearLabel (h, day) {
        var color = day.current === true ? this.color : void 0;
        var slot = this.$scopedSlots['day-of-year'];
        var slotData = Object.assign({}, day);

        return h('div', this.setTextColor(color, {
          staticClass: 'q-calendar-weekly__day-month--day-of-year'
        }), slot ? slot(slotData) : day.doy)
      },

      __renderDayMonth: function __renderDayMonth (h, day) {
        var color = day.current === true ? this.color : void 0;
        var slot = this.$scopedSlots['month-label'];
        var monthLabel = this.monthFormatter(day, this.shortMonthLabel);
        var slotData = Object.assign({}, {monthLabel: monthLabel}, day, {miniMode: this.isMiniMode});

        return h('div', this.setTextColor(color, {
          staticClass: 'q-calendar-weekly__day-month'
        }), slot ? slot(slotData) : this.isMiniMode !== true ? monthLabel : '')
      }
    },

    render: function render (h) {
      return h('div', {
        staticClass: this.staticClass,
        on: {
          dragstart: function (e) {
            e.preventDefault();
          }
        }
      }, [
        !this.hideHeader && this.__renderHead(h) ].concat( this.__renderWeeks(h)
      ))
    }
  };

  // Mixins

  /* @vue/component */
  var QCalendarMonthly = {
    name: 'QCalendarMonthly',

    mixins: [
      QCalendarWeekly
    ],

    computed: {
      parsedStart: function parsedStart () {
        return getStartOfMonth(parseTimestamp(this.start))
      },

      parsedEnd: function parsedEnd () {
        return getEndOfMonth(parseTimestamp(this.end))
      }
    }
  };

  var Resize = {
    name: 'resize',

    inserted: function inserted (el, binding) {
      var callback = binding.value;
      var options = binding.options || { passive: true };

      window.addEventListener('resize', callback, options);
      el._onResize = {
        callback: callback,
        options: options
      };

      if (!binding.modifiers || !binding.modifiers.quiet) {
        callback();
      }
    },

    unbind: function unbind (el) {
      if (!el._onResize) { return }

      var ref = el._onResize;
      var callback = ref.callback;
      var options = ref.options;
      window.removeEventListener('resize', callback, options);
      delete el._onResize;
    }
  };

  // Mixins

  var CalendarIntervals = {
    name: 'CalendarWithIntervals',

    mixins: [
      CalendarBase
    ],

    props: Object.assign({}, props.intervals),

    computed: {
      parsedIntervalStart: function parsedIntervalStart () {
        return parseInt(this.intervalStart, 10)
      },

      parsedIntervalMinutes: function parsedIntervalMinutes () {
        return parseInt(this.intervalMinutes, 10)
      },

      parsedIntervalCount: function parsedIntervalCount () {
        return parseInt(this.intervalCount, 10)
      },

      parsedIntervalHeight: function parsedIntervalHeight () {
        return parseFloat(this.intervalHeight)
      },

      startMinute: function startMinute () {
        return this.parsedIntervalStart * this.parsedIntervalMinutes
      },

      bodyHeight: function bodyHeight () {
        return this.parsedIntervalCount * this.parsedIntervalHeight
      },

      days: function days () {
        return createDayList(
          this.parsedStart,
          this.parsedEnd,
          this.times.today,
          this.weekdaySkips,
          this.disabledBefore,
          this.disabledAfter,
          this.disabledWeekdays,
          this.disabledDays,
          this.maxDays
        )
      },

      intervals: function intervals () {
        var days = this.days;
        var first = this.parsedIntervalStart;
        var minutes = this.parsedIntervalMinutes;
        var count = this.parsedIntervalCount;
        var now = this.times.now;

        if (days.length === 0) {
          /* eslint-disable no-console */
          console.error('QCalendar: days array has no content');
        }
        return days.map(function (d) { return createIntervalList(d, first, minutes, count, now); })
      },

      intervalFormatter: function intervalFormatter () {
        var longOptions = { timeZone: 'UTC', hour12: !this.hour24Format, hour: '2-digit', minute: '2-digit' };
        var shortOptions = { timeZone: 'UTC', hour12: !this.hour24Format, hour: 'numeric', minute: '2-digit' };
        var shortHourOptions = { timeZone: 'UTC', hour12: !this.hour24Format, hour: 'numeric' };

        return createNativeLocaleFormatter(
          this.locale,
          function (tms, short) { return short ? (tms.minute === 0 ? shortHourOptions : shortOptions) : longOptions; }
        )
      }
    },

    methods: {
      showIntervalLabelDefault: function showIntervalLabelDefault (interval) {
        var first = this.intervals[0][0];
        var isFirst = first.hour === interval.hour && first.minute === interval.minute;
        return !isFirst && interval.minute === 0
      },

      intervalStyleDefault: function intervalStyleDefault (_interval) {
        return undefined
      },

      getTimestampAtEvent: function getTimestampAtEvent (e, day) {
        var timestamp = copyTimestamp(day);
        var bounds = (e.currentTarget).getBoundingClientRect();
        var baseMinutes = this.startMinute;
        var touchEvent = e;
        var mouseEvent = e;
        var touches = touchEvent.changedTouches || touchEvent.touches;
        var clientY = touches && touches[0] ? touches[0].clientY : mouseEvent.clientY;
        var addIntervals = (clientY - bounds.top) / this.parsedIntervalHeight;
        var addMinutes = Math.floor(addIntervals * this.parsedIntervalMinutes);
        var minutes = baseMinutes + addMinutes;

        return updateMinutes(timestamp, minutes, this.times.now)
      },

      getScopeForSlot: function getScopeForSlot (timestamp, idx) {
        var scope = copyTimestamp(timestamp);
        scope.timeStartPos = this.timeStartPos;
        scope.timeDurationHeight = this.timeDurationHeight;
        if (idx !== void 0) {
          scope.index = idx;
        }
        return scope
      },

      scrollToTime: function scrollToTime (time) {
        var y = this.timeStartPos(time);
        var pane = this.$refs.scrollArea;

        if (y === false || !pane) {
          return false
        }

        pane.scrollTop = y;

        return true
      },

      timeDurationHeight: function timeDurationHeight (minutes) {
        return minutes / this.parsedIntervalMinutes * this.parsedIntervalHeight
      },

      timeStartPos: function timeStartPos (time, clamp) {
        if ( clamp === void 0 ) clamp = true;

        var minutes = parseTime(time);
        if (minutes === false) { return false }

        var min = this.startMinute;
        var gap = this.parsedIntervalCount * this.parsedIntervalMinutes;
        var delta = (minutes - min) / gap;
        var y = delta * this.bodyHeight;

        if (clamp) {
          if (y < 0) {
            y = 0;
          }
          if (y > this.bodyHeight) {
            y = this.bodyHeight;
          }
        }

        return y
      }
    }
  };

  // Quasar

  /* @vue/component */
  var QCalendarDaily = {
    name: 'QCalendarDaily',

    mixins: [
      CalendarIntervals
    ],

    directives: { Resize: Resize },

    data: function data () {
      return {
        scrollWidth: 0
      }
    },

    computed: {
      computedWidth: function computedWidth () {
        return 100 / this.days.length
      }
    },

    mounted: function mounted () {
      this.init();
    },

    watch: {
      noScroll: function noScroll (val) {
        if (val === true) {
          this.scrollWidth = 0;
        } else {
          this.$nextTick(this.onResize);
        }
      }
    },

    methods: {
      init: function init () {
        this.$nextTick(this.onResize);
      },

      onResize: function onResize () {
        this.scrollWidth = this.getScrollWidth();
      },

      getScrollWidth: function getScrollWidth () {
        var area = this.$refs.scrollArea;
        var pane = this.$refs.pane;

        return area && pane ? (area.offsetWidth - pane.offsetWidth) : 0
      },

      __renderHead: function __renderHead (h) {
        return h('div', {
          staticClass: 'q-calendar-daily__head',
          style: {
            marginRight: this.scrollWidth + 'px'
          }
        }, [
          this.__renderHeadIntervals(h) ].concat( this.__renderHeadDays(h)
        ))
      },

      __renderHeadIntervals: function __renderHeadIntervals (h) {
        var intervalsHeader = this.$scopedSlots['intervals-header'];

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorIntervalHeader';
          backgroundColor = 'backgroundIntervalHeader';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-daily__intervals-head q-calendar-daily__intervals-head--text'
        }), [
          intervalsHeader && intervalsHeader(this.days)
        ])
      },

      __renderHeadDays: function __renderHeadDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount !== void 0 && parseInt(this.columnCount, 10) > 0) {
          // return [...new Array(parseInt(this.columnCount, 10))]
          return Array.apply(null, new Array(parseInt(this.columnCount, 10)))
            .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
            .map(function (idx) { return this$1.__renderHeadDay(h, this$1.days[0], idx); })
        } else {
          return this.days.map(function (day) { return this$1.__renderHeadDay(h, day); })
        }
      },

      __renderHeadDay: function __renderHeadDay (h, day, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['day-header'];
        var scope = this.getScopeForSlot(day, idx);
        var width = this.computedWidth;
        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorHeaderPast';
            backgroundColor = 'backgroundHeaderPast';
          } else if (day.current === true) {
            color = 'colorHeaderCurrent';
            backgroundColor = 'backgroundHeaderCurrent';
          } else if (day.future === true) {
            color = 'colorHeaderFuture';
            backgroundColor = 'backgroundHeaderFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date + (idx !== void 0 ? ("-" + idx) : ''),
          staticClass: 'q-calendar-daily__head-day',
          class: Object.assign({}, this.getRelativeClasses(day),
            {'q-calendar-daily__head-day--droppable': dragOver}),
          style: {
            maxWidth: width + '%'
          },
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, day, 'day', idx);
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, day, 'day', idx);
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':day', function (event) {
            return { scope: scope, event: event }
          })
        }), [
          this.columnHeaderBefore === true && this.__renderColumnHeaderBefore(h, day, idx),
          this.noDefaultHeaderText !== true && this.__renderHeadWeekday(h, day),
          this.noDefaultHeaderBtn !== true && this.__renderHeadDayBtn(h, day),
          slot && slot(scope),
          this.columnHeaderAfter === true && this.__renderColumnHeaderAfter(h, day, idx)
        ])
      },

      __renderHeadWeekday: function __renderHeadWeekday (h, day) {
        var slot = this.$scopedSlots['day-header-label'];
        var scope = this.getScopeForSlot(day);
        var colorCurrent = day.current === true ? this.color : void 0;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorDayLabelPast';
            backgroundColor = 'backgroundDayLabelPast';
          } else if (day.current === true) {
            color = 'colorDayLabelCurrent';
            backgroundColor = 'backgroundDayLabelCurrent';
          } else if (day.future === true) {
            color = 'colorDayLabelFuture';
            backgroundColor = 'backgroundDayLabelFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          staticClass: 'ellipsis q-calendar-daily__head-weekday'
        }), [
          (slot && slot(scope)) || this.__renderHeadDayLabel(h, day, this.shortWeekdayLabel)
        ])
      },

      __renderHeadDayLabel: function __renderHeadDayLabel (h, day, label) {
        return h('span', {
          staticClass: 'ellipsis'
        }, this.weekdayFormatter(day, label))
      },

      __renderHeadDayBtn: function __renderHeadDayBtn (h, day) {
        var colorCurrent = day.current === true ? this.color : void 0;
        var activeDate = this.value === day.date;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorDayLabelPast';
            backgroundColor = 'backgroundDayLabelPast';
          } else if (day.current === true) {
            color = 'colorDayLabelCurrent';
            backgroundColor = 'backgroundDayLabelCurrent';
          } else if (day.future === true) {
            color = 'colorDayLabelFuture';
            backgroundColor = 'backgroundDayLabelFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h(quasar.QBtn, updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-daily__head-day-label',
          class: [
            {
              'q-active-date': this.noActiveDate !== true && activeDate
            }
          ],
          style: {
            color: day.current === true ? colorCurrent : void 0
          },
          props: {
            unelevated: true,
            round: true,
            dense: true,
            noCaps: true,
            outline: day.current === true,
            disable: day.disabled
          },
          on: this.getMouseEventHandlers({
            'click:date': { event: 'click', stop: true },
            'contextmenu:date': { event: 'contextmenu', stop: true, prevent: true, result: false }
          }, function (_event) { return day; })
        }), this.dayFormatter(day, false))
      },

      __renderColumnHeaderBefore: function __renderColumnHeaderBefore (h, day, idx) {
        var slot = this.$scopedSlots['column-header-before'];
        var scope = Object.assign({}, day);
        scope.index = idx;
        return h('div', {
          staticClass: 'q-calendar-daily__column-header--before'
        }, [
          slot && slot(scope)
        ])
      },

      __renderColumnHeaderAfter: function __renderColumnHeaderAfter (h, day, idx) {
        var slot = this.$scopedSlots['column-header-after'];
        var scope = Object.assign({}, day);
        scope.index = idx;
        return h('div', {
          staticClass: 'q-calendar-daily__column-header--after'
        }, [
          slot && slot(scope)
        ])
      },

      __renderBody: function __renderBody (h) {
        return h('div', {
          staticClass: 'q-calendar-daily__body'
        }, [
          this.__renderScrollArea(h)
        ])
      },

      __renderScrollArea: function __renderScrollArea (h) {
        if (this.noScroll !== void 0 && this.noScroll === true) {
          return this.__renderPane(h)
        } else {
          return h('div', {
            ref: 'scrollArea',
            staticClass: 'q-calendar-daily__scroll-area'
          }, [
            this.__renderPane(h)
          ])
        }
      },

      __renderPane: function __renderPane (h) {
        return h('div', {
          ref: 'pane',
          staticClass: 'q-calendar-daily__pane',
          style: {
            height: convertToUnit(this.bodyHeight)
          }
        }, [
          this.__renderDayContainer(h)
        ])
      },

      __renderDayContainer: function __renderDayContainer (h) {
        var slot = this.$scopedSlots['day-container'];
        return h('div', {
          staticClass: 'q-calendar-daily__day-container'
        }, [
          this.__renderBodyIntervals(h) ].concat( this.__renderDays(h),
          [slot && slot(this.days)]
        ))
      },

      __renderDays: function __renderDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount && parseInt(this.columnCount, 10) > 0) {
          return Array.apply(null, new Array(parseInt(this.columnCount, 10)))
            .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
            .map(function (i) { return this$1.__renderDay(h, this$1.days[0], 0, i); })
        } else {
          return this.days.map(function (day, index) { return this$1.__renderDay(h, day, index); })
        }
      },

      __renderDay: function __renderDay (h, day, dayIndex, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['day-body'];
        var scope = this.getScopeForSlot(day, idx);
        var width = this.computedWidth;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorBodyPast';
            backgroundColor = 'backgroundBodyPast';
          } else if (day.current === true) {
            color = 'colorBodyCurrent';
            backgroundColor = 'backgroundBodyCurrent';
          } else if (day.future === true) {
            color = 'colorBodyFuture';
            backgroundColor = 'backgroundBodyFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date + (idx !== void 0 ? (":" + idx) : ''),
          staticClass: 'q-calendar-daily__day',
          class: this.getRelativeClasses(day),
          style: {
            maxWidth: width + '%'
          },
          on: this.getDefaultMouseEventHandlers(':time', function (event) {
            var scope = this$1.getScopeForSlot(this$1.getTimestampAtEvent(event, day), idx);
            return { scope: scope, event: event }
          })
        }), this.__renderDayIntervals(h, dayIndex, idx).concat( [slot && slot(scope)]
        ))
      },

      __renderDayIntervals: function __renderDayIntervals (h, index, idx) {
        var this$1 = this;

        return this.intervals[index].map(function (interval) { return this$1.__renderDayInterval(h, interval, idx); })
      },

      __renderDayInterval: function __renderDayInterval (h, interval, idx) {
        var this$1 = this;

        var height = convertToUnit(this.intervalHeight);
        var styler = this.intervalStyle || this.intervalStyleDefault;
        var slot = this.$scopedSlots.interval;
        var scope = this.getScopeForSlot(interval, idx);
        var dragOver;

        var data = {
          key: interval.time,
          staticClass: 'q-calendar-daily__day-interval',
          class: {
            'q-calendar-daily__day-interval--droppable': dragOver
          },
          style: Object.assign({}, {height: height},
            styler(interval)),
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, interval, 'interval');
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, interval, 'interval');
              }
            }
          }
        };

        var children = slot ? slot(scope) : void 0;

        return h('div', data, children)
      },

      __renderBodyIntervals: function __renderBodyIntervals (h) {
        var this$1 = this;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorIntervalBody';
          backgroundColor = 'backgroundIntervalBody';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        var data = {
          staticClass: 'q-calendar-daily__intervals-body',
          on: this.getDefaultMouseEventHandlers(':interval', function (_event) {
            return this$1.getTimestampAtEvent(_event, this$1.parsedStart)
          })
        };

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), data), this.__renderIntervalLabels(h))
      },

      __renderIntervalLabels: function __renderIntervalLabels (h) {
        var this$1 = this;

        return this.intervals[0].map(function (interval) { return this$1.__renderIntervalLabel(h, interval); })
      },

      __renderIntervalLabel: function __renderIntervalLabel (h, interval) {
        var height = convertToUnit(this.intervalHeight);
        var short = this.shortIntervalLabel;
        var shower = this.showIntervalLabel || this.showIntervalLabelDefault;
        var show = shower(interval);
        var label = show ? this.intervalFormatter(interval, short) : void 0;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorIntervalText';
          backgroundColor = 'backgroundIntervalText';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', {
          key: interval.time,
          staticClass: 'q-calendar-daily__interval',
          style: {
            height: height
          }
        }, [
          h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
            staticClass: 'q-calendar-daily__interval-text'
          }), label)
        ])
      }
    },

    render: function render (h) {
      return h('div', {
        staticClass: 'q-calendar-daily',
        directives: [{
          modifiers: { quiet: true },
          name: 'resize',
          value: this.onResize
        }]
      }, [
        !this.hideHeader && this.__renderHead(h),
        this.__renderBody(h)
      ])
    }
  };

  // Mixins

  var CalendarScheduler = {
    name: 'CalendarWithScheduler',

    mixins: [
      CalendarBase
    ],

    props: Object.assign({}, props.scheduler),

    computed: {
      parsedResourceHeight: function parsedResourceHeight () {
        return parseFloat(this.resourceHeight)
      },

      parsedResourceWidth: function parsedResourceWidth () {
        return parseFloat(this.resourceWidth)
      },

      bodyHeight: function bodyHeight () {
        if (this.resources && this.resources.length > 0) {
          return this.resources.length * this.parsedResourceHeight
        }
        return 0
      },

      days: function days () {
        return createDayList(
          this.parsedStart,
          this.parsedEnd,
          this.times.today,
          this.weekdaySkips,
          this.disabledBefore,
          this.disabledAfter,
          this.disabledWeekdays,
          this.disabledDays,
          this.maxDays
        )
      }
    },

    methods: {
      resourceStyleDefault: function resourceStyleDefault (_timestamp) {
        return undefined
      },

      getTimestampAtEvent: function getTimestampAtEvent (e, day) {
        var timestamp = copyTimestamp(day);
        return updateRelative(timestamp, this.times.now, false)
      },

      getScopeForSlot: function getScopeForSlot (timestamp, idx, resource) {
        var scope = {};
        scope.day = copyTimestamp(timestamp);
        if (idx !== void 0) {
          scope.index = idx;
        }
        if (resource !== void 0) {
          scope.resource = resource;
        }
        return scope
      }
    }
  };

  // Quasar

  /* @vue/component */
  var QCalendarScheduler = {
    name: 'QCalendarScheduler',

    mixins: [
      CalendarScheduler
    ],

    directives: { Resize: Resize },

    data: function data () {
      return {
        scrollWidth: 0
      }
    },

    mounted: function mounted () {
      this.init();
    },

    watch: {
      noScroll: function noScroll (val) {
        if (val === true) {
          this.scrollWidth = 0;
        } else {
          this.$nextTick(this.onResize);
        }
      }
    },

    methods: {
      init: function init () {
        this.$nextTick(this.onResize);
      },

      onResize: function onResize () {
        this.scrollWidth = this.getScrollWidth();
      },

      getScrollWidth: function getScrollWidth () {
        var area = this.$refs.scrollArea;
        var pane = this.$refs.pane;

        return area && pane ? (area.offsetWidth - pane.offsetWidth) : 0
      },

      resourceStartPos: function resourceStartPos (resource, clamp) {
        if ( clamp === void 0 ) clamp = true;

        var index = this.resource.indexOf(resource);
        var y = index * this.parsedResourceHeight;

        if (clamp) {
          if (y < 0) {
            y = 0;
          }
          if (y > this.bodyHeight) {
            y = this.bodyHeight;
          }
        }

        return y
      },

      __renderHead: function __renderHead (h) {
        return h('div', {
          staticClass: 'q-calendar-scheduler__head',
          style: {
            marginRight: this.scrollWidth + 'px'
          }
        }, [
          this.__renderHeadResources(h) ].concat( this.__renderHeadDays(h)
        ))
      },

      __renderHeadResources: function __renderHeadResources (h) {
        var slot = this.$scopedSlots['scheduler-resources-header'];
        var width = convertToUnit(this.resourceWidth);

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorSchedulerHeader';
          backgroundColor = 'backgroundSchedulerHeader';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-scheduler__resources-head q-calendar-scheduler__resources-head--text',
          style: {
            width: width
          }
        }), [
          slot && slot(this.days)
        ])
      },

      __renderHeadDays: function __renderHeadDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount && parseInt(this.columnCount, 10) > 0) {
          return Array.apply(null, new Array(parseInt(this.columnCount, 10)))
            .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
            .map(function (idx) { return this$1.__renderHeadDay(h, this$1.days[0], idx); })
        } else {
          return this.days.map(function (day) { return this$1.__renderHeadDay(h, day); })
        }
      },

      __renderHeadDay: function __renderHeadDay (h, day, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['scheduler-day-header'];
        var scope = this.getScopeForSlot(day, idx);
        var width = 100 / this.days.length;
        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorHeaderPast';
            backgroundColor = 'backgroundHeaderPast';
          } else if (day.current === true) {
            color = 'colorHeaderCurrent';
            backgroundColor = 'backgroundHeaderCurrent';
          } else if (day.future === true) {
            color = 'colorHeaderFuture';
            backgroundColor = 'backgroundHeaderFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date + (idx !== void 0 ? ("-" + idx) : ''),
          staticClass: 'q-calendar-scheduler__head-day',
          class: Object.assign({}, this.getRelativeClasses(day),
            {'q-calendar-scheduler__head-day--droppable': dragOver}),
          style: {
            maxWidth: width + '%'
          },
          domProps: {
            ondragover: function (_event) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(_event, day, 'day', idx);
              }
            },
            ondrop: function (_event) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(_event, day, 'day', idx);
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':day', function (event) {
            return { scope: scope, event: event }
          })
        }), [
          this.columnHeaderBefore === true && this.__renderColumnHeaderBefore(h, day, idx),
          this.noDefaultHeaderText !== true && this.__renderHeadWeekday(h, day, idx),
          this.noDefaultHeaderBtn !== true && this.__renderHeadDayBtn(h, day, idx),
          slot && slot(scope),
          this.columnHeaderAfter === true && this.__renderColumnHeaderAfter(h, day, idx)
        ])
      },

      __renderHeadWeekday: function __renderHeadWeekday (h, day) {
        var colorCurrent = day.current === true ? this.color : void 0;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorDayLabelPast';
            backgroundColor = 'backgroundDayLabelPast';
          } else if (day.current === true) {
            color = 'colorDayLabelCurrent';
            backgroundColor = 'backgroundDayLabelCurrent';
          } else if (day.future === true) {
            color = 'colorDayLabelFuture';
            backgroundColor = 'backgroundDayLabelFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          staticClass: 'ellipsis q-calendar-scheduler__head-weekday'
        }), [
          this.__renderHeadDayLabel(h, day, this.shortWeekdayLabel)
        ])
      },

      __renderHeadDayLabel: function __renderHeadDayLabel (h, day, label) {
        return h('span', {
          staticClass: 'ellipsis'
        }, this.weekdayFormatter(day, label))
      },

      __renderHeadDayBtn: function __renderHeadDayBtn (h, day, idx) {
        var colorCurrent = day.current === true ? this.color : void 0;
        var activeDate = this.value === day.date;

        var scope = { day: day, idx: idx };
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorDayLabelPast';
            backgroundColor = 'backgroundDayLabelPast';
          } else if (day.current === true) {
            color = 'colorDayLabelCurrent';
            backgroundColor = 'backgroundDayLabelCurrent';
          } else if (day.future === true) {
            color = 'colorDayLabelFuture';
            backgroundColor = 'backgroundDayLabelFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h(quasar.QBtn, updateColors(colorCurrent !== void 0 ? colorCurrent : colors.get(color), colors.get(backgroundColor), {
          staticClass: 'q-calendar-scheduler__head-day-label',
          class: [
            {
              'q-active-date': this.noActiveDate !== true && activeDate
            }
          ],
          style: {
            color: day.current === true ? colorCurrent : void 0
          },
          props: {
            unelevated: true,
            round: true,
            dense: true,
            noCaps: true,
            outline: day.current === true,
            disable: day.disabled
          },
          on: this.getMouseEventHandlers({
            'click:date': { event: 'click', stop: true },
            'contextmenu:date': { event: 'contextmenu', stop: true, prevent: true, result: false }
          }, function (_event) { return scope; })
        }), this.dayFormatter(day, false))
      },

      __renderColumnHeaderBefore: function __renderColumnHeaderBefore (h, day, idx) {
        var slot = this.$scopedSlots['scheduler-column-header-before'];
        var scope = Object.assign({}, day);
        scope.index = idx;
        return h('div', {
          staticClass: 'q-calendar-scheduler__column-header--before'
        }, [
          slot && slot(scope)
        ])
      },

      __renderColumnHeaderAfter: function __renderColumnHeaderAfter (h, day, idx) {
        var slot = this.$scopedSlots['scheduler-column-header-after'];
        var scope = Object.assign({}, day);
        scope.index = idx;
        return h('div', {
          staticClass: 'q-calendar-scheduler__column-header--after'
        }, [
          slot && slot(scope)
        ])
      },

      __renderBody: function __renderBody (h) {
        return h('div', {
          staticClass: 'q-calendar-scheduler__body'
        }, [
          this.__renderScrollArea(h)
        ])
      },

      __renderScrollArea: function __renderScrollArea (h) {
        if (this.noScroll !== void 0 && this.noScroll === true) {
          return this.__renderPane(h)
        } else {
          return h('div', {
            ref: 'scrollArea',
            staticClass: 'q-calendar-scheduler__scroll-area'
          }, [
            this.__renderPane(h)
          ])
        }
      },

      __renderPane: function __renderPane (h) {
        return h('div', {
          ref: 'pane',
          staticClass: 'q-calendar-scheduler__pane',
          style: {
            height: convertToUnit(this.bodyHeight)
          }
        }, [
          this.__renderDayContainer(h)
        ])
      },

      __renderDayContainer: function __renderDayContainer (h) {
        return h('div', {
          staticClass: 'q-calendar-scheduler__day-container'
        }, [
          this.__renderBodyResources(h) ].concat( this.__renderDays(h)
        ))
      },

      __renderDays: function __renderDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount && parseInt(this.columnCount, 10) > 0) {
          return Array.apply(null, new Array(parseInt(this.columnCount, 10)))
            .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
            .map(function (i) { return this$1.__renderDay(h, this$1.days[0], 0, i); })
        } else {
          return this.days.map(function (day, index) { return this$1.__renderDay(h, day, index); })
        }
      },

      __renderDay: function __renderDay (h, day, idx) {
        var width = 100 / this.days.length;
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorBodyPast';
            backgroundColor = 'backgroundBodyPast';
          } else if (day.current === true) {
            color = 'colorBodyCurrent';
            backgroundColor = 'backgroundBodyCurrent';
          } else if (day.future === true) {
            color = 'colorBodyFuture';
            backgroundColor = 'backgroundBodyFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date + (idx !== void 0 ? (":" + idx) : ''),
          staticClass: 'q-calendar-scheduler__day',
          class: this.getRelativeClasses(day),
          style: {
            maxWidth: width + '%'
          }
        }), [].concat( this.__renderDayResources(h, day, idx) ))
      },

      __renderDayResources: function __renderDayResources (h, day, idx) {
        var this$1 = this;

        return this.resources.map(function (resource) { return this$1.__renderDayResource(h, resource, day, idx); })
      },

      __renderDayResource: function __renderDayResource (h, resource, day, idx) {
        var this$1 = this;

        var height = convertToUnit(this.resourceHeight);
        var styler = this.resourceStyle || this.resourceStyleDefault;
        var slot = this.$scopedSlots['scheduler-resource-day'];
        var scope = this.getScopeForSlot(day, idx, resource);
        var dragOver;

        var style = { height: height };
        style = Object.assign(style, styler(scope));

        var data = {
          key: resource[this.resourceKey] + '-' + idx,
          staticClass: 'q-calendar-scheduler__day-resource',
          class: {
            'q-calendar-scheduler__day-resource--droppable': dragOver
          },
          style: style,
          domProps: {
            ondragover: function (_event) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(_event, resource, 'resource', idx);
              }
            },
            ondrop: function (_event) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(_event, resource, 'resource', idx);
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':resource:day', function (event) {
            var scope = this$1.getScopeForSlot(this$1.getTimestampAtEvent(event, day), idx, resource);
            return { scope: scope, event: event }
          })
        };

        var children = slot ? slot(scope) : void 0;

        return h('div', data, children)
      },

      __renderBodyResources: function __renderBodyResources (h) {
        var width = convertToUnit(this.resourceWidth);
        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorSchedulerBody';
          backgroundColor = 'backgroundSchedulerBody';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        var data = {
          staticClass: 'q-calendar-scheduler__resources-body',
          style: {
            width: width
          }
        };

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), data), this.__renderResourceLabels(h))
      },

      __renderResourceLabels: function __renderResourceLabels (h) {
        var this$1 = this;

        return this.resources.map(function (resource, idx) { return this$1.__renderResourceLabel(h, resource, idx); })
      },

      __renderResourceLabel: function __renderResourceLabel (h, resource, idx) {
        var slot = this.$scopedSlots['scheduler-resource'];
        var scope = {
          resource: resource,
          index: idx
        };
        var height = convertToUnit(this.resourceHeight);
        var label = resource.label;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          color = 'colorSchedulerText';
          backgroundColor = 'backgroundSchedulerText';
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', {
          key: resource.label,
          staticClass: 'q-calendar-scheduler__resource',
          style: {
            height: height
          },
          on: this.getDefaultMouseEventHandlers(':resource', function (event) {
            return { scope: scope, event: event }
          })
        }, [
          slot ? slot(scope) : h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
            staticClass: 'q-calendar-scheduler__resource-text'
          }), label)
        ])
      },

      __renderResourcesError: function __renderResourcesError (h) {
        return h('div', {}, 'No resources have been defined')
      }
    },

    render: function render (h) {
      return h('div', {
        staticClass: 'q-calendar-scheduler',
        directives: [{
          modifiers: { quiet: true },
          name: 'resize',
          value: this.onResize
        }]
      }, [
        !this.hideHeader && this.resources !== void 0 && this.__renderHead(h),
        this.resources !== void 0 && this.__renderBody(h),
        this.resources === void 0 && this.__renderResourcesError(h)
      ])
    }
  };

  // Mixins

  var QCalendarAgenda = {
    name: 'QCalendarAgenda',

    mixins: [
      QCalendarDaily
    ],

    props: Object.assign({}, props.agenda),

    computed: {
      computedColumnCount: function computedColumnCount () {
        return this.days.length +
          (this.leftColumnOptionsValid === true ? this.leftColumnOptions.length : 0) +
          (this.rightColumnOptionsValid === true ? this.rightColumnOptions.length : 0)
      },

      computedWidth: function computedWidth () {
        return 100 / this.computedColumnCount
      },

      leftColumnOptionsValid: function leftColumnOptionsValid () {
        return this.leftColumnOptions !== void 0 && Array.isArray(this.leftColumnOptions)
      },

      rightColumnOptionsValid: function rightColumnOptionsValid () {
        return this.rightColumnOptions !== void 0 && Array.isArray(this.rightColumnOptions)
      }
    },

    methods: {
      __renderHead: function __renderHead (h) {
        return h('div', {
          staticClass: 'q-calendar-daily__head',
          style: {
            marginRight: this.scrollWidth + 'px'
          }
        }, this.__renderHeadDays(h))
      },

      __renderHeadDays: function __renderHeadDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount !== void 0 && parseInt(this.columnCount, 10) > 0) {
          // return [...new Array(parseInt(this.columnCount, 10))]
          return [
            Array.apply(null, new Array(parseInt(this.columnCount, 10)))
              .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
              .map(function (idx) { return this$1.__renderHeadDay(h, this$1.days[0], idx); })
          ]
        } else {
          return [
            this.leftColumnOptionsValid === true && this.leftColumnOptions.map(function (column, _i) { return this$1.__renderColumnHead(h, column, _i); }),
            this.days.map(function (day) { return this$1.__renderHeadDay(h, day); }),
            this.rightColumnOptionsValid === true && this.rightColumnOptions.map(function (column, _i) { return this$1.__renderColumnHead(h, column, _i); })
          ]
        }
      },

      __renderPane: function __renderPane (h) {
        return h('div', {
          ref: 'pane',
          staticClass: 'q-calendar-daily__pane',
          style: {
            // height: convertToUnit(this.bodyHeight)
          }
        }, [
          this.__renderDayContainer(h)
        ])
      },

      __renderBodyIntervals: function __renderBodyIntervals (h) {
        return void 0
      },

      __renderColumnHead: function __renderColumnHead (h, column, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['column-header'];
        var scope = column;
        var width = this.computedWidth;
        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
        //   if (day.past === true) {
        //     color = 'colorHeaderPast'
        //     backgroundColor = 'backgroundHeaderPast'
        //   } else if (day.current === true) {
        //     color = 'colorHeaderCurrent'
        //     backgroundColor = 'backgroundHeaderCurrent'
        //   } else if (day.future === true) {
        //     color = 'colorHeaderFuture'
        //     backgroundColor = 'backgroundHeaderFuture'
        //   }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: (this.columnOptionsId !== void 0 ? column[this.columnOptionsId] : column.id) + (idx !== void 0 ? ("-" + idx) : ''),
          staticClass: 'q-calendar-daily__head-day',
          class: {
            'q-column-day': true,
            'q-calendar-daily__head-day--droppable': dragOver
          },
          style: {
            maxWidth: width + '%'
          },
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, column, 'column', idx);
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, column, 'column', idx);
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':column:head', function (event) {
            return { scope: scope, event: event }
          })
        }), [
          this.noDefaultHeaderText !== true && this.__renderHeadColumn(h, column),
          slot && slot(scope)
        ])
      },

      __renderHeadColumn: function __renderHeadColumn (h, column) {
        var slot = this.$scopedSlots['column-header-label'];
        var scope = column;
        // const colorCurrent = day.current === true ? this.color : void 0

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
        //   if (day.past === true) {
        //     color = 'colorDayLabelPast'
        //     backgroundColor = 'backgroundDayLabelPast'
        //   } else if (day.current === true) {
        //     color = 'colorDayLabelCurrent'
        //     backgroundColor = 'backgroundDayLabelCurrent'
        //   } else if (day.future === true) {
        //     color = 'colorDayLabelFuture'
        //     backgroundColor = 'backgroundDayLabelFuture'
        //   }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          staticClass: 'ellipsis q-calendar-daily__head-weekday'
        }), [
          slot && slot(scope),
          !slot && this.__renderHeadColumnLabel(h, (this.columnOptionsLabel !== void 0 ? column[this.columnOptionsLabel] : column.label))
        ])
      },

      __renderHeadColumnLabel: function __renderHeadColumnLabel (h, label) {
        return h('span', {
          staticClass: 'ellipsis'
        }, label)
      },

      __renderDays: function __renderDays (h) {
        var this$1 = this;

        if (this.days.length === 1 && this.columnCount && parseInt(this.columnCount, 10) > 0) {
          return [
            Array.apply(null, new Array(parseInt(this.columnCount, 10)))
              .map(function (_, i) { return i + parseInt(this$1.columnIndexStart, 10); })
              .map(function (i) { return this$1.__renderDay(h, this$1.days[0], 0, i); })
          ]
        } else {
          return [
            this.leftColumnOptionsValid === true && this.leftColumnOptions.map(function (column, _i) { return this$1.__renderColumn(h, column, _i); }),
            this.days.map(function (day, index) { return this$1.__renderDay(h, day, index); }),
            this.rightColumnOptionsValid === true && this.rightColumnOptions.map(function (column, _i) { return this$1.__renderColumn(h, column, _i); })
          ]
        }
      },

      __renderColumn: function __renderColumn (h, column, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['column-body'];
        var scope = column;
        var width = this.computedWidth;
        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
        //   if (day.past === true) {
        //     color = 'colorBodyPast'
        //     backgroundColor = 'backgroundBodyPast'
        //   } else if (day.current === true) {
        //     color = 'colorBodyCurrent'
        //     backgroundColor = 'backgroundBodyCurrent'
        //   } else if (day.future === true) {
        //     color = 'colorBodyFuture'
        //     backgroundColor = 'backgroundBodyFuture'
        //   }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: (this.columnOptionsId !== void 0 ? column[this.columnOptionsId] : column.id) + '-body-' + (idx !== void 0 ? (":" + idx) : ''),
          staticClass: 'q-calendar-daily__day',
          class: {
            'q-column-day': true,
            'q-calendar-daily__day--droppable': dragOver
          },
          style: {
            maxWidth: width + '%'
          },
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, column, 'column');
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, column, 'column');
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':column', function (event) {
            return { scope: scope, event: event }
          })
        }), [
          slot && slot(scope)
        ])
      },

      __renderDay: function __renderDay (h, day, dayIndex, idx) {
        var this$1 = this;

        var slot = this.$scopedSlots['day-body'];
        var scope = Object.assign({}, day);
        var width = this.computedWidth;
        var dragOver;

        var colors = new Map(), color, backgroundColor;
        var updateColors = this.useDefaultTheme;
        if (this.enableTheme === true) {
          if (day.past === true) {
            color = 'colorBodyPast';
            backgroundColor = 'backgroundBodyPast';
          } else if (day.current === true) {
            color = 'colorBodyCurrent';
            backgroundColor = 'backgroundBodyCurrent';
          } else if (day.future === true) {
            color = 'colorBodyFuture';
            backgroundColor = 'backgroundBodyFuture';
          }
          colors = this.getThemeColors([color, backgroundColor]);
          updateColors = this.setBothColors;
        }

        return h('div', updateColors(colors.get(color), colors.get(backgroundColor), {
          key: day.date + (idx !== void 0 ? (":" + idx) : ''),
          staticClass: 'q-calendar-daily__day',
          class: Object.assign({}, this.getRelativeClasses(day),
            {'q-calendar-daily__day--droppable': dragOver}),
          style: {
            maxWidth: width + '%'
          },
          domProps: {
            ondragover: function (e) {
              if (this$1.dragOverFunc !== void 0) {
                dragOver = this$1.dragOverFunc(e, day, 'day');
              }
            },
            ondrop: function (e) {
              if (this$1.dropFunc !== void 0) {
                this$1.dropFunc(e, day, 'day');
              }
            }
          },
          on: this.getDefaultMouseEventHandlers(':time', function (event) {
            var scope = this$1.getScopeForSlot(this$1.getTimestampAtEvent(event, day), idx);
            return { scope: scope, event: event }
          })
        }), [
          slot && slot(scope)
        ])
      }
    },

    render: function render (h) {
      return h('div', {
        staticClass: 'q-calendar-agenda',
        class: this.classes,
        directives: [{
          modifiers: { quiet: true },
          name: 'resize',
          value: this.onResize
        }]
      }, [
        !this.hideHeader && this.__renderHead(h),
        this.__renderBody(h)
      ])
    }
  };

  // Mixins

  /* @vue/component */
  var QCalendar = {
    name: 'QCalendar',

    mixins: [
      CalendarBase
    ],

    props: Object.assign({}, props.calendar,
      props.weeks,
      props.intervals,
      props.scheduler,
      props.agenda),

    data: function () { return ({
      lastStart: void 0,
      lastEnd: void 0
    }); },

    computed: {
      parsedValue: function parsedValue () {
        return parseTimestamp(this.value) ||
          this.parsedStart ||
          this.times.today
      },

      renderProps: function renderProps () {
        var around = this.parsedValue;
        var component = 'div';
        var maxDays = this.maxDays;
        var start = around;
        var end = around;
        switch (this.view) {
          case 'month':
            component = QCalendarMonthly;
            start = getStartOfMonth(around);
            end = getEndOfMonth(around);
            break
          case 'week':
          case 'week-agenda':
          case 'week-scheduler':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            start = this.getStartOfWeek(around);
            end = this.getEndOfWeek(around);
            maxDays = this.weekdays.length;
            break
          case 'day':
          case 'day-scheduler':
          case 'day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 1;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case '2day':
          case '2day-scheduler':
          case '2day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 2;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case '3day':
          case '3day-scheduler':
          case '3day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 3;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case '4day':
          case '4day-scheduler':
          case '4day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 4;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case '5day':
          case '5day-scheduler':
          case '5day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 5;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case '6day':
          case '6day-scheduler':
          case '6day-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            maxDays = 6;
            end = relativeDays(copyTimestamp(end), nextDay, maxDays, this.weekdays);
            updateFormatted(end);
            break
          case 'custom-interval':
          case 'custom-scheduler':
          case 'custom-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            end = relativeDays(copyTimestamp(end), nextDay, this.maxDays, this.weekdays);
            updateFormatted(end);
            break
          case 'scheduler':
          case 'agenda':
            component = this.view === 'scheduler' ? QCalendarScheduler : QCalendarAgenda;
            end = relativeDays(copyTimestamp(end), nextDay, this.maxDays, this.weekdays);
            updateFormatted(end);
            break
          case 'month-interval':
          case 'month-scheduler':
          case 'month-agenda':
            component = this.view.endsWith('-agenda') ? QCalendarAgenda : this.view.endsWith('-scheduler') ? QCalendarScheduler : QCalendarDaily;
            start = getStartOfMonth(around);
            end = getEndOfMonth(around);
            updateFormatted(end);
            maxDays = DAYS_IN_MONTH_MAX;
            break
        }

        return { component: component, start: start, end: end, maxDays: maxDays }
      }
    },

    beforeMount: function beforeMount () {
      // get start and end dates
      this.__checkChange();
    },

    watch: {
      renderProps: '__checkChange'
    },

    methods: {
      __checkChange: function __checkChange () {
        var ref = this.renderProps;
        var start = ref.start;
        var end = ref.end;
        this.keyValue = 0;
        if (this.lastStart === void 0 || this.lastEnd === void 0 || start.date !== this.lastStart || end.date !== this.lastEnd) {
          this.lastStart = start.date;
          this.lastEnd = end.date;
          this.$emit('change', { start: start, end: end });
        }
        this.keyValue = getDayIdentifier(start);
      },

      move: function move (amount) {
        if ( amount === void 0 ) amount = 1;

        var moved = copyTimestamp(this.parsedValue);
        var forward = amount > 0;
        var mover = forward ? nextDay : prevDay;
        var limit = forward ? DAYS_IN_MONTH_MAX : DAY_MIN;
        var times = forward ? amount : -amount;
        this.direction = forward ? 'next' : 'prev';
        var maxDays = this.maxDays;
        var dayCount = this.weekdaySkips.filter(function (x) { return x !== 0; }).length;

        while (--times >= 0) {
          switch (this.view) {
            case 'month':
              moved.day = limit;
              mover(moved);
              break
            case 'week':
            case 'week-scheduler':
            case 'week-agenda':
            case 'scheduler':
              relativeDays(moved, mover, dayCount, this.weekdays);
              break
            case 'day':
            case 'day-scheduler':
            case 'day-agenda':
              maxDays = 1;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case '2day':
            case '2day-scheduler':
            case '2day-agenda':
              maxDays = 2;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case '3day':
            case '3day-scheduler':
            case '3day-agenda':
              maxDays = 3;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case '4day':
            case '4day-scheduler':
            case '4day-agenda':
              maxDays = 4;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case '5day':
            case '5day-scheduler':
            case '5day-agenda':
              maxDays = 5;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case '6day':
            case '6day-scheduler':
            case '6day-agenda':
              maxDays = 6;
              relativeDays(moved, mover, maxDays, this.weekdays);
              break
            case 'custom-interval':
            case 'custom-scheduler':
            case 'custom-agenda':
            case 'agenda':
              relativeDays(moved, mover, this.maxDays, this.weekdays);
              break
            case 'month-interval':
            case 'month-agenda':
            case 'month-scheduler':
              moved.day = limit;
              mover(moved);
              break
          }
        }

        updateWeekday(moved);
        updateFormatted(moved);
        updateDayOfYear(moved);
        updateRelative(moved, this.times.now);

        this.$emit('input', moved.date);
        this.$emit('moved', moved);
      },

      next: function next (amount) {
        if ( amount === void 0 ) amount = 1;

        this.move(amount);
      },

      prev: function prev (amount) {
        if ( amount === void 0 ) amount = 1;

        this.move(-amount);
      },

      timeStartPos: function timeStartPos (time, clamp) {
        if ( clamp === void 0 ) clamp = true;

        var c = this.$children[0];
        if (c && c.timeStartPos) {
          return c.timeStartPos(time, clamp)
        } else {
          return false
        }
      },

      timeDurationHeight: function timeDurationHeight (minutes) {
        var c = this.$children[0];
        if (c && c.timeDurationHeight) {
          return c.timeDurationHeight(minutes)
        } else {
          return -1
        }
      },

      scrollToTime: function scrollToTime (time) {
        var c = this.$children[0];
        if (c && c.scrollToTime) {
          return c.scrollToTime(time)
        } else {
          return false
        }
      },

      __renderComponent: function __renderComponent (h, component, data) {
        return h(component, data)
      }
    },

    render: function render (h) {
      var this$1 = this;

      var ref = this.renderProps;
      var start = ref.start;
      var end = ref.end;
      var maxDays = ref.maxDays;
      var component = ref.component;

      this.keyValue = getDayIdentifier(start);

      var data = {
        staticClass: 'q-calendar' + (this.dark === true ? ' q-calendar--dark' : ''),
        class: {
          'q-calendar-daily__bordered': this.bordered
        },
        key: this.keyValue,
        props: Object.assign({}, this.$props,
          {start: start.date,
          end: end.date,
          maxDays: maxDays}),
        on: Object.assign({}, this.$listeners,
          {'click:date': function (day) {
            if (this$1.$listeners.input !== void 0) {
              if (day.date !== void 0) {
                this$1.$emit('input', day.date);
              } else if (day.day !== void 0 && day.day.date !== void 0) {
                this$1.$emit('input', day.day.date);
              }
            }
            if (this$1.$listeners['click:date']) {
              this$1.$emit('click:date', day);
            }
          }}),
        scopedSlots: this.$scopedSlots
      };

      if (this.animated === true) {
        var transition = 'q-transition--' + (this.direction === 'prev' ? this.transitionPrev : this.transitionNext);
        return h('transition', {
          props: {
            name: transition,
            appear: true
          }
        }, [
          this.__renderComponent(h, component, data)
        ])
      } else {
        return this.__renderComponent(h, component, data)
      }
    }
  };

  var Plugin = {
    version: version,
    QCalendar: QCalendar,
    // timestamp
    PARSE_REGEX: PARSE_REGEX,
    PARSE_TIME: PARSE_TIME,
    DAYS_IN_MONTH: DAYS_IN_MONTH,
    DAYS_IN_MONTH_LEAP: DAYS_IN_MONTH_LEAP,
    DAYS_IN_MONTH_MIN: DAYS_IN_MONTH_MIN,
    DAYS_IN_MONTH_MAX: DAYS_IN_MONTH_MAX,
    MONTH_MAX: MONTH_MAX,
    MONTH_MIN: MONTH_MIN,
    DAY_MIN: DAY_MIN,
    DAYS_IN_WEEK: DAYS_IN_WEEK,
    MINUTES_IN_HOUR: MINUTES_IN_HOUR,
    HOURS_IN_DAY: HOURS_IN_DAY,
    FIRST_HOUR: FIRST_HOUR,
    MILLISECONDS_IN_DAY: MILLISECONDS_IN_DAY,
    MILLISECONDS_IN_HOUR: MILLISECONDS_IN_HOUR,
    MILLISECONDS_IN_MINUTE: MILLISECONDS_IN_MINUTE,
    Timestamp: Timestamp,
    TimeObject: TimeObject,
    getStartOfWeek: getStartOfWeek,
    getEndOfWeek: getEndOfWeek,
    getStartOfMonth: getStartOfMonth,
    getEndOfMonth: getEndOfMonth,
    parseTime: parseTime,
    validateTimestamp: validateTimestamp,
    parsed: parsed,
    parseTimestamp: parseTimestamp,
    parseDate: parseDate,
    getDayIdentifier: getDayIdentifier,
    getTimeIdentifier: getTimeIdentifier,
    diffTimestamp: diffTimestamp,
    updateRelative: updateRelative,
    updateMinutes: updateMinutes,
    updateWeekday: updateWeekday,
    updateDayOfYear: updateDayOfYear,
    updateWorkWeek: updateWorkWeek,
    updateDisabled: updateDisabled,
    updateFormatted: updateFormatted,
    getDayOfYear: getDayOfYear,
    getWorkWeek: getWorkWeek,
    getWeekday: getWeekday,
    isLeapYear: isLeapYear,
    daysInMonth: daysInMonth,
    copyTimestamp: copyTimestamp,
    padNumber: padNumber,
    getDate: getDate,
    getTime: getTime,
    getDateTime: getDateTime,
    nextDay: nextDay,
    prevDay: prevDay,
    relativeDays: relativeDays,
    moveRelativeDays: moveRelativeDays,
    findWeekday: findWeekday,
    getWeekdaySkips: getWeekdaySkips,
    createDayList: createDayList,
    createIntervalList: createIntervalList,
    createNativeLocaleFormatter: createNativeLocaleFormatter,
    makeDate: makeDate,
    makeDateTime: makeDateTime,
    validateNumber: validateNumber,
    isBetweenDates: isBetweenDates,
    isOverlappingDates: isOverlappingDates,
    daysBetween: daysBetween,
    weeksBetween: weeksBetween,
    addToDate: addToDate,
    // helpers
    convertToUnit: convertToUnit,
    indexOf: indexOf,

    install: function install (Vue) {
      Vue.component(QCalendar.name, QCalendar);
    }
  };

  Vue.use(Plugin);

  exports.DAYS_IN_MONTH = DAYS_IN_MONTH;
  exports.DAYS_IN_MONTH_LEAP = DAYS_IN_MONTH_LEAP;
  exports.DAYS_IN_MONTH_MAX = DAYS_IN_MONTH_MAX;
  exports.DAYS_IN_MONTH_MIN = DAYS_IN_MONTH_MIN;
  exports.DAYS_IN_WEEK = DAYS_IN_WEEK;
  exports.DAY_MIN = DAY_MIN;
  exports.FIRST_HOUR = FIRST_HOUR;
  exports.HOURS_IN_DAY = HOURS_IN_DAY;
  exports.MILLISECONDS_IN_DAY = MILLISECONDS_IN_DAY;
  exports.MILLISECONDS_IN_HOUR = MILLISECONDS_IN_HOUR;
  exports.MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_MINUTE;
  exports.MINUTES_IN_HOUR = MINUTES_IN_HOUR;
  exports.MONTH_MAX = MONTH_MAX;
  exports.MONTH_MIN = MONTH_MIN;
  exports.PARSE_REGEX = PARSE_REGEX;
  exports.PARSE_TIME = PARSE_TIME;
  exports.QCalendar = QCalendar;
  exports.TimeObject = TimeObject;
  exports.Timestamp = Timestamp;
  exports.addToDate = addToDate;
  exports.convertToUnit = convertToUnit;
  exports.copyTimestamp = copyTimestamp;
  exports.createDayList = createDayList;
  exports.createIntervalList = createIntervalList;
  exports.createNativeLocaleFormatter = createNativeLocaleFormatter;
  exports.daysBetween = daysBetween;
  exports.daysInMonth = daysInMonth;
  exports.diffTimestamp = diffTimestamp;
  exports.findWeekday = findWeekday;
  exports.getDate = getDate;
  exports.getDateTime = getDateTime;
  exports.getDayIdentifier = getDayIdentifier;
  exports.getDayOfYear = getDayOfYear;
  exports.getEndOfMonth = getEndOfMonth;
  exports.getEndOfWeek = getEndOfWeek;
  exports.getStartOfMonth = getStartOfMonth;
  exports.getStartOfWeek = getStartOfWeek;
  exports.getTime = getTime;
  exports.getTimeIdentifier = getTimeIdentifier;
  exports.getWeekday = getWeekday;
  exports.getWeekdaySkips = getWeekdaySkips;
  exports.getWorkWeek = getWorkWeek;
  exports.indexOf = indexOf;
  exports.isBetweenDates = isBetweenDates;
  exports.isLeapYear = isLeapYear;
  exports.isOverlappingDates = isOverlappingDates;
  exports.makeDate = makeDate;
  exports.makeDateTime = makeDateTime;
  exports.moveRelativeDays = moveRelativeDays;
  exports.nextDay = nextDay;
  exports.padNumber = padNumber;
  exports.parseDate = parseDate;
  exports.parseTime = parseTime;
  exports.parseTimestamp = parseTimestamp;
  exports.parsed = parsed;
  exports.prevDay = prevDay;
  exports.relativeDays = relativeDays;
  exports.updateDayOfYear = updateDayOfYear;
  exports.updateDisabled = updateDisabled;
  exports.updateFormatted = updateFormatted;
  exports.updateMinutes = updateMinutes;
  exports.updateRelative = updateRelative;
  exports.updateWeekday = updateWeekday;
  exports.updateWorkWeek = updateWorkWeek;
  exports.validateNumber = validateNumber;
  exports.validateTimestamp = validateTimestamp;
  exports.version = version;
  exports.weeksBetween = weeksBetween;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
